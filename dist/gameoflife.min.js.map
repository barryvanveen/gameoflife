{"version":3,"sources":["gameoflife.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","GameOfLife","customConfig","this","_defaults","canvas_id","num_cols","num_rows","cell_size","color_lines","color_cell_empty","color_cell_selected","update_interval","_interval","_initConfig","_initCanvas","_initCells","_initEventListeners","value","config","canvas","document","getElementById","console","log","Error","context","getContext","fillStyle","strokeStyle","width","height","clearRect","x","moveTo","lineTo","y","stroke","row","col","cells","newCells","self","addEventListener","e","_handleClick","attachEvent","cell","_getCellFromCursorPosition","_drawCell","left","top","pageX","pageY","clientX","body","scrollLeft","documentElement","clientY","scrollTop","canvas_offset","getPosition","Math","floor","fillRect","stop","setInterval","_computeNextGeneration","clearInterval","rowOffset","colOffset","neighborCol","neighborRow","count","change","mod","element","offsetParent","offsetLeft","offsetTop","n","m"],"mappings":"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","file":"gameoflife.min.js","sourcesContent":["/*\n * GameOfLife JavaScript Plugin v1.0.0\n * https://github.com/barryvanveen/gameoflife\n *\n * Released under the MIT license\n * http://choosealicense.com/licenses/mit/\n */\n\n// todo: babel instellen https://www.npmjs.com/package/gulp-babel/\n// todo: modules maken voor gameoflife, helpers (getPosition, mod)\n// todo: boel importeren en namespacen\n\nclass GameOfLife {\n\n    constructor(customConfig) {\n        this._defaults = {\n            canvas_id:              \"gameoflife_canvas\",\n            num_cols:               80,\n            num_rows:               40,\n            cell_size:              10,\n            color_lines:            \"#cccccc\",\n            color_cell_empty:       \"#ffffff\",\n            color_cell_selected:    \"#57A0DB\",\n            update_interval:        50\n        };\n        this._interval = null;\n\n        this._initConfig(customConfig);\n        this._initCanvas();\n        this._initCells();\n        this._initEventListeners();\n    };\n\n    _initConfig(customConfig) {\n\n        var i;\n\n        this.config = this._defaults;\n\n        if (typeof(customConfig) != \"object\") {\n            return;\n        }\n\n        for (i in customConfig) {\n            if (typeof(this.config[i]) == \"undefined\" || typeof(customConfig[i]) == \"object\") {\n                continue;\n            }\n            this.config[i] = customConfig[i];\n        }\n\n    };\n\n    _initCanvas() {\n\n        this.canvas = document.getElementById(this.config.canvas_id);\n        console.log(this.canvas);\n\n        if (this.canvas == null) {\n            throw new Error(\"Canvas element could not be found.\");\n        }\n\n        this.context = this.canvas.getContext(\"2d\");\n\n        if (!this.context) {\n            throw new Error(\"Canvas context could not be retrieved.\");\n        }\n\n        this.context.fillStyle = this.config.color_cell_selected;\n        this.context.strokeStyle = this.config.color_lines;\n\n        this.canvas.width = (this.config.num_cols * this.config.cell_size) + 1;\n        this.canvas.height = (this.config.num_rows * this.config.cell_size) + 1;\n\n        // clear the canvas\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        //todo: is inlining cell_size faster?\n\n        // vertical lines\n        for (var x = 0; x <= this.canvas.width; x += this.config.cell_size) {\n            this.context.moveTo(0.5 + x, 0);\n            this.context.lineTo(0.5 + x, this.canvas.width);\n        }\n\n        // horizontal lines\n        for (var y = 0; y <= this.canvas.width; y += this.config.cell_size) {\n            this.context.moveTo(0, 0.5 + y);\n            this.context.lineTo(this.canvas.width, 0.5 + y);\n        }\n\n        // draw it\n        this.context.stroke();\n\n    };\n\n    _initCells() {\n\n        // init two sets of cells:\n        //   cells is the current state\n        //   newCells is used to compute the next state\n\n        var col = this.config.num_cols,\n            row;\n\n        this.cells = [];\n        this.newCells = [];\n\n        while (col--) {\n            this.cells[col] = [];\n            this.newCells[col] = [];\n\n            row = this.config.num_rows;\n            while (row--) {\n                this.cells[col][row] = 0;\n                this.newCells[col][row] = 0;\n            }\n        }\n\n    };\n\n    _initEventListeners() {\n\n        var self = this;\n\n        // todo: test fallback for <=IE10 with attachEvent\n        if (document.addEventListener) {\n\n            this.canvas.addEventListener('click', function(e) {\n                self._handleClick(e);\n            }, false);\n\n        } else if (document.attachEvent) {\n\n            this.canvas.attachEvent('click', function (e) {\n                self._handleClick(e);\n            });\n        }\n\n    };\n\n    _handleClick(e) {\n\n        var cell = this._getCellFromCursorPosition(e);\n\n        if (cell == false) {\n            return;\n        }\n\n        this.cells[cell[0]][cell[1]] = !this.cells[cell[0]][cell[1]];\n        this._drawCell(cell[0], cell[1]);\n\n    };\n\n    _getCellFromCursorPosition(e) {\n\n        var left, top;\n\n        // get coordinates of click on page\n        if (typeof(e.pageX) != \"undefined\" && typeof(e.pageY) != \"undefined\") {\n            left = e.pageX;\n            top = e.pageY;\n        } else {\n            left = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            top = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n\n        // get coordinates relative to canvas\n        var canvas_offset = GameOfLife.getPosition(this.canvas);\n        left -= canvas_offset[0];\n        top -= canvas_offset[1];\n\n        if (left > (this.config.num_cols * this.config.cell_size) || top > (this.config.num_rows * this.config.cell_size)) {\n            return false;\n        }\n\n        // now calculate in which cell this click falls\n        return [Math.floor(left / this.config.cell_size), Math.floor(top / this.config.cell_size)];\n\n    };\n\n    _drawCell(col, row) {\n\n        if (this.cells[col][row]) {\n            this.context.fillStyle = this.config.color_cell_selected;\n        } else {\n            this.context.fillStyle = this.config.color_cell_empty;\n        }\n\n        // fill rectangle from (col-1,row-1) with width and height of cellSize-1\n        // todo: is inlining cell_size faster?\n        this.context.fillRect(1 + (col*this.config.cell_size), 1 + (row*this.config.cell_size), this.config.cell_size-1, this.config.cell_size-1);\n\n    };\n\n    reset() {\n\n        this.stop();\n\n        this._initCells();\n        this._initCanvas();\n\n    };\n\n    start() {\n\n        if (this._interval != null) {\n            return;\n        }\n\n        var self = this;\n\n        // todo: replace with requestAnimationFrame?\n        this._interval = setInterval(function() { self._computeNextGeneration(); }, this.config.update_interval);\n\n    };\n\n    step() {\n\n        clearInterval(this._interval);\n        this._interval = null;\n\n        this._computeNextGeneration();\n\n    };\n\n    stop() {\n\n        clearInterval(this._interval);\n        this._interval = null;\n\n    };\n\n    _computeNextGeneration() {\n\n        var count = 0,\n            change = false,\n            col, row, rowOffset, colOffset, neighborCol, neighborRow;\n\n        // iterate over all cells\n        col = this.config.num_cols;\n        while (col--) {\n\n            row = this.config.num_rows;\n            while (row--) {\n\n                count = 0;\n\n                // iterate over all neighbors in Moore neighborhood with radius=1\n                for (colOffset = -1; colOffset <= 1; ++colOffset) {\n                    for (rowOffset = -1; rowOffset <= 1; ++rowOffset) {\n                        if (colOffset == 0 && rowOffset == 0) {\n                            continue;\n                        }\n\n                        neighborCol = col + colOffset;\n                        if (neighborCol < 0 || neighborCol >= this.config.num_cols) {\n                            neighborCol = GameOfLife.mod(this.config.num_cols, neighborCol);\n                        }\n\n                        neighborRow = row + rowOffset;\n                        if (neighborRow < 0 || neighborRow >= this.config.num_rows) {\n                            neighborRow = GameOfLife.mod(this.config.num_rows, neighborRow);\n                        }\n\n                        // count neighbors that are \"on\" or \"alive\"\n                        if (this.cells[neighborCol][neighborRow]) {\n                            count++;\n                        }\n                    }\n                }\n\n                // determine state of new cells\n                if (count < 2 || count > 3) {\n                    this.newCells[col][row] = 0;\n                } else if (count == 2) {\n                    this.newCells[col][row] = this.cells[col][row];\n                } else { // count == 3\n                    this.newCells[col][row] = 1;\n                }\n\n            }\n        }\n\n        // todo: is keeping an array of changed cells faster?\n        // update cells for new generation\n        col = this.config.num_cols;\n        while (col--) {\n\n            row = this.config.num_rows;\n            while (row--) {\n\n                // only update when old and new cell differ\n                if (this.cells[col][row] != this.newCells[col][row]) {\n\n                    // todo: is \"this.cells[col][row] = !this.cells[col][row];\" faster??\n                    this.cells[col][row] = this.newCells[col][row];\n                    this._drawCell(col, row);\n                    change = true;\n\n                }\n            }\n        }\n\n        // if no cells were changed we can stop\n        if (!change) {\n            this.stop();\n        }\n\n    };\n\n    /*\n     * Helpers\n     */\n\n    static getPosition(element) {\n\n        var left = 0,\n            top = 0;\n\n        if (element.offsetParent) {\n            do {\n                left += element.offsetLeft;\n                top += element.offsetTop;\n            } while (element = element.offsetParent);\n        }\n\n        return [left, top];\n\n    };\n\n    static mod(n, m) {\n        return ((m % n) + n) % n;\n    };\n\n}\n"],"sourceRoot":"/source/"}