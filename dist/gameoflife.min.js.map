{"version":3,"sources":["gameoflife.js"],"names":["GameOfLife","defaults","canvas_id","num_cols","num_rows","cell_size","color_lines","color_cell_empty","color_cell_selected","update_interval","init","config","this","_initConfig","_initCanvas","_initCells","_initEventListeners","interval","i","constants","canvas","document","getElementById","Error","context","getContext","fillStyle","strokeStyle","canvas_offset","_getPosition","width","height","clearRect","x","moveTo","lineTo","y","stroke","element","left","top","offsetParent","offsetLeft","offsetTop","row","col","cells","newCells","self","addEventListener","e","_handleClick","attachEvent","cell","_getCellFromCursorPosition","_drawCell","pageX","pageY","clientX","body","scrollLeft","documentElement","clientY","scrollTop","Math","floor","fillRect","reset","stop","start","setInterval","_computeNextGeneration","step","clearInterval","rowOffset","colOffset","neighborCol","neighborRow","count","change","_mod","n","m"],"mappings":"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","file":"gameoflife.min.js","sourcesContent":["/*\r\n * GameOfLife JavaScript Plugin v1.0.0\r\n * https://github.com/barryvanveen/gameoflife\r\n *\r\n * Released under the MIT license\r\n * http://choosealicense.com/licenses/mit/\r\n */\r\nGameOfLife = {};\r\n\r\nGameOfLife.defaults = {\r\n\r\n    canvas_id:              \"gameoflife_canvas\",\r\n    num_cols:               80,\r\n    num_rows:               40,\r\n    cell_size:              10,\r\n    color_lines:            \"#cccccc\",\r\n    color_cell_empty:       \"#ffffff\",\r\n    color_cell_selected:    \"#57A0DB\",\r\n    update_interval:        50\r\n\r\n};\r\n\r\nGameOfLife.init = function(config) {\r\n\r\n    this._initConfig(config);\r\n\r\n    this._initCanvas();\r\n\r\n    this._initCells();\r\n\r\n    this._initEventListeners();\r\n\r\n    this.interval = null;\r\n\r\n};\r\n\r\nGameOfLife._initConfig = function(config) {\r\n\r\n    var i;\r\n\r\n    this.config = this.defaults;\r\n\r\n    if (typeof(config) != \"object\") {\r\n        return;\r\n    }\r\n\r\n    for (i in config) {\r\n        if (typeof(this.config[i]) == \"undefined\" || typeof(config[i]) == \"object\") {\r\n            continue;\r\n        }\r\n        this.config[i] = config[i];\r\n    }\r\n\r\n    for (i in this.constants) {\r\n        this.config[i] = this.constants[i];\r\n    }\r\n\r\n};\r\n\r\nGameOfLife._initCanvas = function() {\r\n\r\n    this.canvas = document.getElementById(this.config.canvas_id);\r\n\r\n    if (this.canvas == null) {\r\n        throw new Error(\"Canvas element could not be found.\");\r\n    }\r\n\r\n    this.context = this.canvas.getContext(\"2d\");\r\n\r\n    if (!this.context) {\r\n        throw new Error(\"Canvas context could not be retrieved.\");\r\n    }\r\n\r\n    this.context.fillStyle = this.config.color_cell_selected;\r\n    this.context.strokeStyle = this.config.color_lines;\r\n\r\n    this.config.canvas_offset = this._getPosition(this.canvas);\r\n\r\n    this.canvas.width = (this.config.num_cols * this.config.cell_size) + 1;\r\n    this.canvas.height = (this.config.num_rows * this.config.cell_size) + 1;\r\n\r\n    // clear the canvas\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    //todo: is inlining cell_size faster?\r\n\r\n    // vertical lines\r\n    for (var x = 0; x <= this.canvas.width; x += this.config.cell_size) {\r\n        this.context.moveTo(0.5 + x, 0);\r\n        this.context.lineTo(0.5 + x, this.canvas.width);\r\n    }\r\n\r\n    // horizontal lines\r\n    for (var y = 0; y <= this.canvas.width; y += this.config.cell_size) {\r\n        this.context.moveTo(0, 0.5 + y);\r\n        this.context.lineTo(this.canvas.width, 0.5 + y);\r\n    }\r\n\r\n    // draw it\r\n    this.context.stroke();\r\n\r\n};\r\n\r\nGameOfLife._getPosition = function(element) {\r\n\r\n    var left = 0,\r\n        top = 0;\r\n\r\n    if (element.offsetParent) {\r\n        do {\r\n            left += element.offsetLeft;\r\n            top += element.offsetTop;\r\n        } while (element = element.offsetParent);\r\n    }\r\n\r\n    return [left, top];\r\n\r\n};\r\n\r\nGameOfLife._initCells = function() {\r\n\r\n    // init two sets of cells:\r\n    //   cells is the current state\r\n    //   newCells is used to compute the next state\r\n\r\n    var col = this.config.num_cols,\r\n        row;\r\n\r\n    this.cells = [];\r\n    this.newCells = [];\r\n\r\n    while (col--) {\r\n        this.cells[col] = [];\r\n        this.newCells[col] = [];\r\n\r\n        row = this.config.num_rows;\r\n        while (row--) {\r\n            this.cells[col][row] = 0;\r\n            this.newCells[col][row] = 0;\r\n        }\r\n    }\r\n\r\n};\r\n\r\nGameOfLife._initEventListeners = function() {\r\n\r\n    var self = this;\r\n\r\n    // todo: test fallback for <=IE10 with attachEvent\r\n    // https://msdn.microsoft.com/en-us/library/ms536343%28VS.85%29.aspx\r\n    if (document.addEventListener) {\r\n\r\n        this.canvas.addEventListener('click', function(e) {\r\n            self._handleClick(e);\r\n        }, false);\r\n\r\n    } else if (document.attachEvent) {\r\n\r\n        this.canvas.attachEvent('click', function (e) {\r\n            self._handleClick(e);\r\n        });\r\n    }\r\n\r\n};\r\n\r\nGameOfLife._handleClick = function(e) {\r\n\r\n    var cell = this._getCellFromCursorPosition(e);\r\n\r\n    if (cell == false) {\r\n        return;\r\n    }\r\n\r\n    this.cells[cell[0]][cell[1]] = !this.cells[cell[0]][cell[1]];\r\n    this._drawCell(cell[0], cell[1]);\r\n\r\n};\r\n\r\n\r\nGameOfLife._getCellFromCursorPosition = function(e) {\r\n\r\n    var left, top;\r\n\r\n    // get coordinates of click on page\r\n    if (typeof(e.pageX) != \"undefined\" && typeof(e.pageY) != \"undefined\") {\r\n        left = e.pageX;\r\n        top = e.pageY;\r\n    } else {\r\n        left = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\r\n        top = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\r\n    }\r\n\r\n    // get coordinates relative to canvas\r\n    left -= this.config.canvas_offset[0];\r\n    top -= this.config.canvas_offset[1];\r\n\r\n    if (left > (this.config.num_cols * this.config.cell_size) || top > (this.config.num_rows * this.config.cell_size)) {\r\n        return false;\r\n    }\r\n\r\n    // now calculate in which cell this falls\r\n    return [Math.floor(left / this.config.cell_size), Math.floor(top / this.config.cell_size)];\r\n\r\n};\r\n\r\nGameOfLife._drawCell = function(col, row) {\r\n\r\n    if (this.cells[col][row]) {\r\n        this.context.fillStyle = this.config.color_cell_selected;\r\n    } else {\r\n        this.context.fillStyle = this.config.color_cell_empty;\r\n    }\r\n\r\n    // fill rectangle from (col-1,row-1) with width and height of cellSize-1\r\n    // todo: is inlining cell_size faster?\r\n    this.context.fillRect(1 + (col*this.config.cell_size), 1 + (row*this.config.cell_size) , this.config.cell_size-1, this.config.cell_size-1);\r\n\r\n};\r\n\r\nGameOfLife.reset = function() {\r\n\r\n    this.stop();\r\n\r\n    this._initCells();\r\n    this._initCanvas();\r\n\r\n};\r\n\r\nGameOfLife.start = function() {\r\n\r\n    if (this.interval != null) {\r\n        return;\r\n    }\r\n\r\n    var self = this;\r\n    this.interval = setInterval(function() { self._computeNextGeneration(); }, this.config.update_interval);\r\n\r\n};\r\n\r\nGameOfLife.step = function() {\r\n\r\n    clearInterval(this.interval);\r\n    this.interval = null;\r\n\r\n    this._computeNextGeneration();\r\n\r\n};\r\n\r\nGameOfLife.stop = function() {\r\n\r\n    clearInterval(this.interval);\r\n    this.interval = null;\r\n\r\n};\r\n\r\nGameOfLife._computeNextGeneration = function() {\r\n\r\n    var count = 0,\r\n        change = false,\r\n        col, row, rowOffset, colOffset, neighborCol, neighborRow;\r\n\r\n    // iterate over all cells\r\n    col = this.config.num_cols;\r\n    while (col--) {\r\n\r\n        row = this.config.num_rows;\r\n        while (row--) {\r\n\r\n            count = 0;\r\n\r\n            // iterate over all neighbors in Moore neighborhood with radius=1\r\n            for (colOffset = -1; colOffset <= 1; ++colOffset) {\r\n                for (rowOffset = -1; rowOffset <= 1; ++rowOffset) {\r\n                    if (colOffset == 0 && rowOffset == 0) {\r\n                        continue;\r\n                    }\r\n\r\n                    neighborCol = col + colOffset;\r\n                    if (neighborCol < 0 || neighborCol >= this.config.num_cols) {\r\n                        neighborCol = this._mod(this.config.num_cols, neighborCol);\r\n                    }\r\n\r\n                    neighborRow = row + rowOffset;\r\n                    if (neighborRow < 0 || neighborRow >= this.config.num_rows) {\r\n                        neighborRow = this._mod(this.config.num_rows, neighborRow);\r\n                    }\r\n\r\n                    // count neighbors that are \"on\" or \"alive\"\r\n                    if (this.cells[neighborCol][neighborRow]) {\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // determine state of new cells\r\n            if (count < 2 || count > 3) {\r\n                this.newCells[col][row] = 0;\r\n            } else if (count == 2) {\r\n                this.newCells[col][row] = this.cells[col][row];\r\n            } else { // count == 3\r\n                this.newCells[col][row] = 1;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // todo: is keeping an array of changed cells faster?\r\n    // update cells for new generation\r\n    col = this.config.num_cols;\r\n    while (col--) {\r\n\r\n        row = this.config.num_rows;\r\n        while (row--) {\r\n\r\n            // only update when old and new cell differ\r\n            if (this.cells[col][row] != this.newCells[col][row]) {\r\n\r\n                // todo: is \"this.cells[col][row] = !this.cells[col][row];\" faster??\r\n                this.cells[col][row] = this.newCells[col][row];\r\n                this._drawCell(col, row);\r\n                change = true;\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    // if no cells were changed we can stop\r\n    if (!change) {\r\n        this.stop();\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Return a modulo that works for negative numbers (eg. -2%10=8)\r\n */\r\nGameOfLife._mod = function(n, m) {\r\n    return ((m % n) + n) % n;\r\n};"],"sourceRoot":"/source/"}