{"version":3,"sources":["gameoflife.js"],"names":["Barryvanveen","GameOfLife","this","init","customConfig","initConfig","initCanvas","initCells","initEventListeners","interval","i","config","defaults","canvas","document","getElementById","canvas_id","console","log","Error","context","getContext","fillStyle","color_cell_selected","strokeStyle","color_lines","canvas_offset","getPosition","width","num_cols","cell_size","height","num_rows","clearRect","x","moveTo","lineTo","y","stroke","element","left","top","offsetParent","offsetLeft","offsetTop","row","col","cells","newCells","self","addEventListener","e","handleClick","attachEvent","cell","getCellFromCursorPosition","drawCell","pageX","pageY","clientX","body","scrollLeft","documentElement","clientY","scrollTop","Math","floor","color_cell_empty","fillRect","reset","stop","start","setInterval","computeNextGeneration","update_interval","step","clearInterval","rowOffset","colOffset","neighborCol","neighborRow","count","change","mod","n","m"],"mappings":"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","file":"gameoflife.min.js","sourcesContent":["/*\n * GameOfLife JavaScript Plugin v1.0.0\n * https://github.com/barryvanveen/gameoflife\n *\n * Released under the MIT license\n * http://choosealicense.com/licenses/mit/\n */\nvar Barryvanveen = Barryvanveen || {};\n\nBarryvanveen.GameOfLife = Barryvanveen.GameOfLife || function () {\n\n    /*\n     * Methods\n     */\n\n    this.init = function(customConfig) {\n\n        this.initConfig(customConfig);\n        this.initCanvas();\n        this.initCells();\n        this.initEventListeners();\n\n        this.interval = null;\n    };\n\n    this.initConfig = function(customConfig) {\n\n        var i;\n\n        this.config = this.defaults;\n\n        if (typeof(customConfig) != \"object\") {\n            return;\n        }\n\n        for (i in customConfig) {\n            if (typeof(this.config[i]) == \"undefined\" || typeof(customConfig[i]) == \"object\") {\n                continue;\n            }\n            this.config[i] = customConfig[i];\n        }\n\n    };\n\n    this.initCanvas = function() {\n\n        this.canvas = document.getElementById(this.config.canvas_id);\n        console.log(this.canvas);\n\n        if (this.canvas == null) {\n            throw new Error(\"Canvas element could not be found.\");\n        }\n\n        this.context = this.canvas.getContext(\"2d\");\n\n        if (!this.context) {\n            throw new Error(\"Canvas context could not be retrieved.\");\n        }\n\n        this.context.fillStyle = this.config.color_cell_selected;\n        this.context.strokeStyle = this.config.color_lines;\n\n        this.config.canvas_offset = this.getPosition(this.canvas);\n        console.log(this.config.canvas_offset);\n\n        this.canvas.width = (this.config.num_cols * this.config.cell_size) + 1;\n        this.canvas.height = (this.config.num_rows * this.config.cell_size) + 1;\n\n        // clear the canvas\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        //todo: is inlining cell_size faster?\n\n        // vertical lines\n        for (var x = 0; x <= this.canvas.width; x += this.config.cell_size) {\n            this.context.moveTo(0.5 + x, 0);\n            this.context.lineTo(0.5 + x, this.canvas.width);\n        }\n\n        // horizontal lines\n        for (var y = 0; y <= this.canvas.width; y += this.config.cell_size) {\n            this.context.moveTo(0, 0.5 + y);\n            this.context.lineTo(this.canvas.width, 0.5 + y);\n        }\n\n        // draw it\n        this.context.stroke();\n\n    };\n\n    this.getPosition = function(element) {\n\n        var left = 0,\n            top = 0;\n\n        if (element.offsetParent) {\n            do {\n                left += element.offsetLeft;\n                top += element.offsetTop;\n            } while (element = element.offsetParent);\n        }\n\n        return [left, top];\n\n    };\n\n    this.initCells = function() {\n\n        // init two sets of cells:\n        //   cells is the current state\n        //   newCells is used to compute the next state\n\n        var col = this.config.num_cols,\n            row;\n\n        this.cells = [];\n        this.newCells = [];\n\n        while (col--) {\n            this.cells[col] = [];\n            this.newCells[col] = [];\n\n            row = this.config.num_rows;\n            while (row--) {\n                this.cells[col][row] = 0;\n                this.newCells[col][row] = 0;\n            }\n        }\n\n    };\n\n    this.initEventListeners = function() {\n\n        var self = this;\n\n        // todo: test fallback for <=IE10 with attachEvent\n        if (document.addEventListener) {\n\n            this.canvas.addEventListener('click', function(e) {\n                self.handleClick(e);\n            }, false);\n\n        } else if (document.attachEvent) {\n\n            this.canvas.attachEvent('click', function (e) {\n                self.handleClick(e);\n            });\n        }\n\n    };\n\n    this.handleClick = function(e) {\n\n        var cell = this.getCellFromCursorPosition(e);\nconsole.log(cell);\n        if (cell == false) {\n            return;\n        }\n\n        this.cells[cell[0]][cell[1]] = !this.cells[cell[0]][cell[1]];\n        this.drawCell(cell[0], cell[1]);\n\n    };\n\n    this.getCellFromCursorPosition = function(e) {\n\n        var left, top;\n\n        // get coordinates of click on page\n        if (typeof(e.pageX) != \"undefined\" && typeof(e.pageY) != \"undefined\") {\n            left = e.pageX;\n            top = e.pageY;\n        } else {\n            left = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            top = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n\n        console.log(this.config.canvas_offset);\n\n        // get coordinates relative to canvas\n        left -= this.config.canvas_offset[0];\n        top -= this.config.canvas_offset[1];\n\n        if (left > (this.config.num_cols * this.config.cell_size) || top > (this.config.num_rows * this.config.cell_size)) {\n            return false;\n        }\n\n        // now calculate in which cell this click falls\n        return [Math.floor(left / this.config.cell_size), Math.floor(top / this.config.cell_size)];\n\n    };\n\n    this.drawCell = function(col, row) {\n\n        if (this.cells[col][row]) {\n            this.context.fillStyle = this.config.color_cell_selected;\n        } else {\n            this.context.fillStyle = this.config.color_cell_empty;\n        }\n\n        // fill rectangle from (col-1,row-1) with width and height of cellSize-1\n        // todo: is inlining cell_size faster?\n        this.context.fillRect(1 + (col*this.config.cell_size), 1 + (row*this.config.cell_size), this.config.cell_size-1, this.config.cell_size-1);\n\n    };\n\n    this.reset = function() {\n\n        this.stop();\n\n        this.initCells();\n        this.initCanvas();\n\n    };\n\n    this.start = function() {\n\n        if (this.interval != null) {\n            return;\n        }\n\n        var self = this;\n\n        // todo: replace with requestAnimationFrame?\n        this.interval = setInterval(function() { self.computeNextGeneration(); }, this.config.update_interval);\n\n    };\n\n    this.step = function() {\n\n        clearInterval(this.interval);\n        this.interval = null;\n\n        this.computeNextGeneration();\n\n    };\n\n    this.stop = function() {\n\n        clearInterval(this.interval);\n        this.interval = null;\n\n    };\n\n    this.computeNextGeneration = function() {\n\n        var count = 0,\n            change = false,\n            col, row, rowOffset, colOffset, neighborCol, neighborRow;\n\n        // iterate over all cells\n        col = this.config.num_cols;\n        while (col--) {\n\n            row = this.config.num_rows;\n            while (row--) {\n\n                count = 0;\n\n                // iterate over all neighbors in Moore neighborhood with radius=1\n                for (colOffset = -1; colOffset <= 1; ++colOffset) {\n                    for (rowOffset = -1; rowOffset <= 1; ++rowOffset) {\n                        if (colOffset == 0 && rowOffset == 0) {\n                            continue;\n                        }\n\n                        neighborCol = col + colOffset;\n                        if (neighborCol < 0 || neighborCol >= this.config.num_cols) {\n                            neighborCol = this.mod(this.config.num_cols, neighborCol);\n                        }\n\n                        neighborRow = row + rowOffset;\n                        if (neighborRow < 0 || neighborRow >= this.config.num_rows) {\n                            neighborRow = this.mod(this.config.num_rows, neighborRow);\n                        }\n\n                        // count neighbors that are \"on\" or \"alive\"\n                        if (this.cells[neighborCol][neighborRow]) {\n                            count++;\n                        }\n                    }\n                }\n\n                // determine state of new cells\n                if (count < 2 || count > 3) {\n                    this.newCells[col][row] = 0;\n                } else if (count == 2) {\n                    this.newCells[col][row] = this.cells[col][row];\n                } else { // count == 3\n                    this.newCells[col][row] = 1;\n                }\n\n            }\n        }\n\n        // todo: is keeping an array of changed cells faster?\n        // update cells for new generation\n        col = this.config.num_cols;\n        while (col--) {\n\n            row = this.config.num_rows;\n            while (row--) {\n\n                // only update when old and new cell differ\n                if (this.cells[col][row] != this.newCells[col][row]) {\n\n                    // todo: is \"this.cells[col][row] = !this.cells[col][row];\" faster??\n                    this.cells[col][row] = this.newCells[col][row];\n                    this.drawCell(col, row);\n                    change = true;\n\n                }\n            }\n        }\n\n        // if no cells were changed we can stop\n        if (!change) {\n            this.stop();\n        }\n\n    };\n\n    this.mod = function(n, m) {\n        return ((m % n) + n) % n;\n    };\n\n    /*\n     * Variables\n     */\n\n    this.defaults = {\n\n        canvas_id:              \"gameoflife_canvas\",\n        num_cols:               80,\n        num_rows:               40,\n        cell_size:              10,\n        color_lines:            \"#cccccc\",\n        color_cell_empty:       \"#ffffff\",\n        color_cell_selected:    \"#57A0DB\",\n        update_interval:        50\n\n    };\n};\n"],"sourceRoot":"/source/"}